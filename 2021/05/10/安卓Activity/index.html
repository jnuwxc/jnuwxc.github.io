<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.3/css/all.min.css" integrity="sha256-2H3fkXt6FEmrReK448mDVGKb3WW2ZZw35gI7vqHOE4Y=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{&quot;hostname&quot;:&quot;jnuwxc.github.io&quot;,&quot;root&quot;:&quot;&#x2F;&quot;,&quot;images&quot;:&quot;&#x2F;images&quot;,&quot;scheme&quot;:&quot;Muse&quot;,&quot;version&quot;:&quot;8.5.0&quot;,&quot;exturl&quot;:false,&quot;sidebar&quot;:{&quot;position&quot;:&quot;left&quot;,&quot;display&quot;:&quot;post&quot;,&quot;padding&quot;:18,&quot;offset&quot;:12},&quot;copycode&quot;:false,&quot;bookmark&quot;:{&quot;enable&quot;:false,&quot;color&quot;:&quot;#222&quot;,&quot;save&quot;:&quot;auto&quot;},&quot;fancybox&quot;:false,&quot;mediumzoom&quot;:false,&quot;lazyload&quot;:false,&quot;pangu&quot;:false,&quot;comments&quot;:{&quot;style&quot;:&quot;tabs&quot;,&quot;active&quot;:null,&quot;storage&quot;:true,&quot;lazyload&quot;:false,&quot;nav&quot;:null},&quot;motion&quot;:{&quot;enable&quot;:true,&quot;async&quot;:false,&quot;transition&quot;:{&quot;post_block&quot;:&quot;fadeIn&quot;,&quot;post_header&quot;:&quot;fadeInDown&quot;,&quot;post_body&quot;:&quot;fadeInDown&quot;,&quot;coll_header&quot;:&quot;fadeInLeft&quot;,&quot;sidebar&quot;:&quot;fadeInUp&quot;}},&quot;prism&quot;:false,&quot;i18n&quot;:{&quot;placeholder&quot;:&quot;搜索...&quot;,&quot;empty&quot;:&quot;没有找到任何搜索结果：${query}&quot;,&quot;hits_time&quot;:&quot;找到 ${hits} 个搜索结果（用时 ${time} 毫秒）&quot;,&quot;hits&quot;:&quot;找到 ${hits} 个搜索结果&quot;}}</script><script src="/js/config.js"></script>
<meta name="description" content="安卓Activity[toc] 生命周期Activity 类提供六个核心回调：onCreate()、onStart()、onResume()、onPause()、onStop() 和 onDestroy()。当 Activity 进入新状态时，系统会调用其中每个回调。   onCreate()  创建。此时activity会进入创建的状态。 必须实现的回调，它会在系统首次创建 Activity 时">
<meta property="og:type" content="article">
<meta property="og:title" content="wxc的博客">
<meta property="og:url" content="http://jnuwxc.github.io/2021/05/10/%E5%AE%89%E5%8D%93Activity/index.html">
<meta property="og:site_name" content="wxc的博客">
<meta property="og:description" content="安卓Activity[toc] 生命周期Activity 类提供六个核心回调：onCreate()、onStart()、onResume()、onPause()、onStop() 和 onDestroy()。当 Activity 进入新状态时，系统会调用其中每个回调。   onCreate()  创建。此时activity会进入创建的状态。 必须实现的回调，它会在系统首次创建 Activity 时">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://developer.android.google.cn/guide/components/images/activity_lifecycle.png">
<meta property="og:image" content="https://developer.android.google.cn/images/fundamentals/diagram_backstack.png">
<meta property="article:published_time" content="2021-05-10T07:00:29.624Z">
<meta property="article:modified_time" content="2021-05-17T06:43:11.056Z">
<meta property="article:author" content="wxc">
<meta property="article:tag" content="Android, 安卓, android">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://developer.android.google.cn/guide/components/images/activity_lifecycle.png">


<link rel="canonical" href="http://jnuwxc.github.io/2021/05/10/%E5%AE%89%E5%8D%93Activity/">



<script class="next-config" data-name="page" type="application/json">{&quot;sidebar&quot;:&quot;&quot;,&quot;isHome&quot;:false,&quot;isPost&quot;:true,&quot;lang&quot;:&quot;zh-CN&quot;,&quot;comments&quot;:true,&quot;permalink&quot;:&quot;http:&#x2F;&#x2F;jnuwxc.github.io&#x2F;2021&#x2F;05&#x2F;10&#x2F;%E5%AE%89%E5%8D%93Activity&#x2F;&quot;,&quot;path&quot;:&quot;2021&#x2F;05&#x2F;10&#x2F;安卓Activity&#x2F;&quot;,&quot;title&quot;:&quot;&quot;}</script>

<script class="next-config" data-name="calendar" type="application/json">&quot;&quot;</script>
<title> | wxc的博客</title>
  




  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">wxc的博客</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>







</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%AE%89%E5%8D%93Activity"><span class="nav-number">1.</span> <span class="nav-text">安卓Activity</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="nav-number">1.1.</span> <span class="nav-text">生命周期</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BF%9D%E5%AD%98%E5%92%8C%E6%81%A2%E5%A4%8D%E7%95%8C%E9%9D%A2%E7%8A%B6%E6%80%81"><span class="nav-number">1.2.</span> <span class="nav-text">保存和恢复界面状态</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#onSaveInstanceState"><span class="nav-number">1.2.1.</span> <span class="nav-text">onSaveInstanceState()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ViewModel"><span class="nav-number">1.2.2.</span> <span class="nav-text">ViewModel</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%B7%B3%E8%BD%AC"><span class="nav-number">1.3.</span> <span class="nav-text">跳转</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%BB%E5%8A%A1%E5%92%8C%E8%BF%94%E5%9B%9E%E6%A0%88"><span class="nav-number">1.4.</span> <span class="nav-text">任务和返回栈</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%BB%E5%8A%A1"><span class="nav-number">1.4.1.</span> <span class="nav-text">任务</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%90%AF%E5%8A%A8%E6%A8%A1%E5%BC%8F-launchMode"><span class="nav-number">1.4.2.</span> <span class="nav-text">启动模式(launchMode)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8Intent%E6%A0%87%E8%AE%B0"><span class="nav-number">1.4.3.</span> <span class="nav-text">使用Intent标记</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Application%E7%9B%B8%E5%85%B3"><span class="nav-number">1.5.</span> <span class="nav-text">Application相关</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Application%E7%B1%BB"><span class="nav-number">1.5.1.</span> <span class="nav-text">Application类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#lt-application-gt-%E6%A0%87%E7%AD%BE"><span class="nav-number">1.5.2.</span> <span class="nav-text">&lt;application&gt;标签</span></a></li></ol></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">wxc</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives">
          <span class="site-state-item-count">9</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">1</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>



        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://jnuwxc.github.io/2021/05/10/%E5%AE%89%E5%8D%93Activity/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="wxc">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="wxc的博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-05-10 15:00:29" itemprop="dateCreated datePublished" datetime="2021-05-10T15:00:29+08:00">2021-05-10</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2021-05-17 14:43:11" itemprop="dateModified" datetime="2021-05-17T14:43:11+08:00">2021-05-17</time>
      </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <h1 id="安卓Activity"><a href="#安卓Activity" class="headerlink" title="安卓Activity"></a>安卓Activity</h1><p>[toc]</p>
<h2 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h2><p>Activity 类提供六个核心回调：<code>onCreate()</code>、<code>onStart()</code>、<code>onResume()</code>、<code>onPause()</code>、<code>onStop()</code> 和 <code>onDestroy()</code>。当 Activity 进入新状态时，系统会调用其中每个回调。</p>
<p><img src="https://developer.android.google.cn/guide/components/images/activity_lifecycle.png" alt="img"></p>
<ul>
<li><strong>onCreate()</strong></li>
</ul>
<p>创建。此时activity会进入创建的状态。</p>
<p>必须实现的回调，它会在系统首次创建 Activity 时触发。Activity 会在创建后进入“已创建”状态。应该在<code>onCreate()</code>中执行基本应用启动逻辑，该逻辑在 Activity 的整个生命周期中只应发生一次。常见的执行操作如：声明界面（在 XML 布局文件中定义）、定义成员变量，以及配置某些界面。具体到日常开发中，XML中view的绑定、点击事件以及<code>onSaveInstanceState</code>数据的处理都应在此处理。</p>
<p>已创建状态并不会持续，完成后会立刻进入已开始状态。</p>
<ul>
<li><strong>onStart()</strong></li>
</ul>
<p>开始。此时activity会进入可见状态。</p>
<p>当 Activity 进入“已开始”状态时，系统会调用此回调。<code>onStart()</code> 调用使 Activity 对用户可见，因为应用会为 Activity 进入前台并支持互动做准备。例如，应用通过此方法来初始化维护界面的代码。该方法会非常快速地完成，并且与“已创建”状态一样，Activity 不会一直处于“已开始”状态。</p>
<p>什么代码应该在<code>onStart()</code>中编写呢？好像一直在<code>onCreate()</code>中写初始化的逻辑。</p>
<ul>
<li><strong>onResume()</strong></li>
</ul>
<p>恢复。此时activity会进入与用户交互的状态。</p>
<p>这是应用与用户互动的状态。应用会一直保持这种状态，直到某些事件发生，让焦点远离应用。当发生中断事件时，Activity 进入“已暂停”状态，系统调用 <code>onPause()</code> 回调。</p>
<p>如果 Activity 从“已暂停”状态返回“已恢复”状态，系统将再次调用 <code>onResume()</code> 方法。因此，您应实现 <code>onResume()</code>，以初始化在 <code>onPause() </code>期间释放的组件，并执行每次 Activity 进入“已恢复”状态时必须完成的任何其他初始化操作。</p>
<ul>
<li><strong>onPause()</strong></li>
</ul>
<p>暂停。此时activity会进入暂停状态，不再位于前台，不可与用户进行交互，但仍可见。</p>
<p><code>onPause()</code> 执行非常简单，而且不一定要有足够的时间来执行保存操作。因此，您<strong>不</strong>应使用 <code>onPause()</code> 来保存应用或用户数据、进行网络调用或执行数据库事务。因为在该方法完成之前，此类工作可能无法完成。相反，您应在 <code>onStop()</code> 期间执行高负载的关闭操作。</p>
<p><code>onPause()</code> 方法的完成并不意味着 Activity 离开“已暂停”状态。相反，Activity 会保持此状态，直到其恢复或变成对用户完全不可见，即调用<code>onResume</code>或者<code>onStop</code>。</p>
<ul>
<li><strong>onStop()</strong></li>
</ul>
<p>停止。此时 Activity 不再对用户可见。</p>
<p>在 <code>onStop()</code> 方法中，应用应释放或调整在应用对用户不可见时的无用资源。例如，应用可以暂停动画效果，或从精确位置更新切换到粗略位置更新。还应使用 <code>onStop()</code> 执行 CPU 相对密集的关闭操作。例如，如果无法找到更合适的时机来将信息保存到数据库，可以在 <code>onStop()</code> 期间执行此操作。</p>
<ul>
<li><strong>onDestory()</strong></li>
</ul>
<p>销毁。在activity彻底关闭之前调用。</p>
<p>进入销毁状态的原因可能有两个：activity即将结束(finish()或者用户关闭)，或由于配置变更（设备旋转或多窗口）</p>
<p>如果 Activity 即将结束，onDestroy() 是 Activity 收到的最后一个生命周期回调。如果由于配置变更而调用 onDestroy()，系统会立即新建 Activity 实例，然后在新配置中为新实例调用 <code>onCreate()</code></p>
<p><code>onDestroy()</code> 回调应释放先前的回调（例如 <code>onStop()</code>）尚未释放的所有资源。</p>
<p><strong>协调 Activity</strong></p>
<p>生命周期回调的顺序已有明确定义，特别是当两个 Activity 在同一个进程（应用）中，并且其中一个要启动另一个时。以下是 Activity A 启动 Activity B 时的操作发生顺序：</p>
<ol>
<li>Activity A 的 <code>onPause()</code> 方法执行。</li>
<li>Activity B 的 <code>onCreate()</code>、<code>onStart()</code> 和 <code>onResume()</code> 方法依次执行（Activity B 现在具有用户焦点）。</li>
<li>然后，如果 Activity A 在屏幕上不再显示，其 <code>onStop()</code> 方法执行。</li>
</ol>
<h2 id="保存和恢复界面状态"><a href="#保存和恢复界面状态" class="headerlink" title="保存和恢复界面状态"></a>保存和恢复界面状态</h2><p>用户期望 Activity 的界面状态在整个配置变更（例如旋转或切换到多窗口模式）期间保持不变。但是，默认情况下，系统会在发生此类配置更改时销毁 Activity，从而清除存储在 Activity 实例中的任何界面状态。。当您的 Activity 因用户按下返回按钮或因其自行结束而被销毁时，系统和用户对该 <code>Activity</code>实例的概念将永远消失。在这些情况下，用户的期望与系统行为相匹配，您无需完成任何额外工作。</p>
<p>当 Activity 因系统限制而被销毁时，您应组合使用 <a target="_blank" rel="noopener" href="https://developer.android.google.cn/reference/androidx/lifecycle/ViewModel"><code>ViewModel</code></a>、<a target="_blank" rel="noopener" href="https://developer.android.google.cn/reference/android/app/Activity#onSaveInstanceState(android.os.Bundle)"><code>onSaveInstanceState()</code></a> 和/或本地存储来保留用户的瞬时界面状态。如果界面数据简单且轻量，例如原始数据类型或简单对象，您可以单独使用 <code>onSaveInstanceState()</code> 使界面状态在配置更改和系统启动的进程被终止时保持不变。</p>
<h3 id="onSaveInstanceState"><a href="#onSaveInstanceState" class="headerlink" title="onSaveInstanceState()"></a>onSaveInstanceState()</h3><p>当您的 Activity 开始停止时，系统会调用 <code>onSaveInstanceState()</code> 方法，此方法会在<code>onStop()</code>之后调用。可以在<code>protected void onCreate(Bundle savedInstanceState) </code>的参数中获取该数据。按我的理解，好像只有横竖屏幕切换用得到这个？</p>
<p><strong>注意</strong>：当用户显式关闭 Activity 时（如点击返回按钮，或者直接关闭等），或者在其他情况下调用 <code>finish()</code> 时，系统不会调用 <code>onSaveInstanceState()</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onSaveInstanceState</span><span class="params">(<span class="meta">@NonNull</span> Bundle outState)</span> </span>&#123;</span><br><span class="line">    outState.putInt(<span class="string">&quot;test&quot;</span>, <span class="number">19</span>);</span><br><span class="line">    Log.d(TAG, <span class="string">&quot;onSaveInstanceState: 正在被销毁，保存数据ing&quot;</span>);</span><br><span class="line">    <span class="keyword">super</span>.onSaveInstanceState(outState);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">    setContentView(R.layout.activity_main);</span><br><span class="line">    <span class="keyword">if</span>(savedInstanceState != <span class="keyword">null</span>)&#123;</span><br><span class="line">        Log.d(TAG, <span class="string">&quot;onCreate: &quot;</span> + savedInstanceState.getInt(<span class="string">&quot;test&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="ViewModel"><a href="#ViewModel" class="headerlink" title="ViewModel"></a>ViewModel</h3><p>这部分估计要重开一篇了，内容有点多。</p>
<h2 id="跳转"><a href="#跳转" class="headerlink" title="跳转"></a>跳转</h2><p>根据Activity 是否希望从即将启动的新 Activity 中获取返回结果，您可以使用 <code>startActivity()</code> 或 <code>startActivityForResult()</code> 方法启动新 Activity。这两种方法都需要传入一个 <code>Intent</code> 对象，Intent的更多用法，后面再总结。</p>
<ul>
<li><code>startActivity()</code></li>
</ul>
<p>直接显式启动一个activity</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Intent intent = <span class="keyword">new</span> Intent(<span class="keyword">this</span>, SignInActivity.class);</span><br><span class="line">startActivity(intent);</span><br></pre></td></tr></table></figure>

<p>隐式启动一个activity</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Intent intent = <span class="keyword">new</span> Intent(Intent.ACTION_SEND);</span><br><span class="line">intent.putExtra(Intent.EXTRA_EMAIL, recipientArray);</span><br><span class="line">startActivity(intent);</span><br></pre></td></tr></table></figure>

<ul>
<li><code>startActivityForResult()</code></li>
</ul>
<p>有时希望在 Activity 结束时从 Activity 中获取返回结果，可以调用 <code>startActivityForResult(Intent, int)</code> 方法，其中整数参数会标识该调用（只是标识同一activity的不同调用）。结果通过重写<code>onActivityResult(int, int, Intent)</code> 方法处理。</p>
<p>当子级 Activity 退出时，它可以调用 <code>setResult(int)</code> 将数据返回到其父级。</p>
<p><strong>注意</strong> 如果子级 Activity 由于任何原因（例如崩溃）而失败，父级 Activity 将收到代码为 <code>RESULT_CANCELED</code> 的结果。即不应该将setResutl方法放在<code>onStop()</code>或<code>onDestory()</code>等回调方法内，而应自己去处理，如按下返回键可以使用<code>onBackPressed()</code>回调来处理。</p>
<h2 id="任务和返回栈"><a href="#任务和返回栈" class="headerlink" title="任务和返回栈"></a>任务和返回栈</h2><h3 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h3><p>任务是一个整体单元，当用户开始一个新任务或通过主屏幕按钮进入主屏幕时，任务可移至“后台”。在后台时，任务中的所有 Activity 都会停止，但任务的返回堆栈会保持不变，当其他任务启动时，当前任务只是失去了焦点。如果用户稍后通过点按该任务的启动器图标来恢复该任务，该任务会进入前台并恢复堆栈顶部的 Activity。简单来说，可以认为任务是activity的一个集合，每个activity可以有多个实例，可以存在于不同任务里，一个任务里面也有可能存在一个activity的多个实例。</p>
<p>任务中的activity会按照启动模式中的默认模式运行，如果想以另外的模式运行，可以借助<code>&lt;activity&gt;</code> 清单元素中的属性以及您传递给 <code>startActivity()</code> 的 intent 中的标记来实现上述目的。</p>
<p>在这方面，您可以使用的主要 <code>&lt;activity&gt;</code>属性包括：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://developer.android.google.cn/guide/topics/manifest/activity-element#aff"><code>taskAffinity</code></a></li>
<li><a target="_blank" rel="noopener" href="https://developer.android.google.cn/guide/topics/manifest/activity-element#lmode"><code>launchMode</code></a></li>
<li><a target="_blank" rel="noopener" href="https://developer.android.google.cn/guide/topics/manifest/activity-element#reparent"><code>allowTaskReparenting</code></a></li>
<li><a target="_blank" rel="noopener" href="https://developer.android.google.cn/guide/topics/manifest/activity-element#clear"><code>clearTaskOnLaunch</code></a></li>
<li><a target="_blank" rel="noopener" href="https://developer.android.google.cn/guide/topics/manifest/activity-element#always"><code>alwaysRetainTaskState</code></a></li>
<li><a target="_blank" rel="noopener" href="https://developer.android.google.cn/guide/topics/manifest/activity-element#finish"><code>finishOnTaskLaunch</code></a></li>
</ul>
<p>您可以使用的主要 intent 标记包括：</p>
<ul>
<li><code>FLAG_ACTIVITY_NEW_TASK</code></li>
<li><code>FLAG_ACTIVITY_CLEAR_TOP</code></li>
<li><code>FLAG_ACTIVITY_SINGLE_TOP</code></li>
</ul>
<h3 id="启动模式-launchMode"><a href="#启动模式-launchMode" class="headerlink" title="启动模式(launchMode)"></a>启动模式(launchMode)</h3><p>在清单文件中声明 Activity 时，可以使用<code>launchMode</code> 属性指定 Activity 应该如何与任务关联。<code>launchMode</code>属性说明了 Activity 应如何启动到任务中。您可以为 <code>launchMode</code> 属性指定 4 种不同的启动模式：</p>
<ul>
<li><code>&quot;standard&quot;</code>（默认模式）</li>
</ul>
<p>默认值。系统在启动该 Activity 的任务中创建 Activity 的新实例，并将 intent 传送给该实例。Activity 可以多次实例化，每个实例可以属于不同的任务，一个任务可以拥有多个实例。</p>
<p>在当前 Activity 启动另一个 Activity 时，新的 Activity 将被推送到堆栈顶部并获得焦点。上一个 Activity 仍保留在堆栈中，但会停止。当 Activity 停止时，系统会保留其界面的当前状态。当用户按<strong>返回</strong>按钮时，当前 Activity 会从堆栈顶部退出（该 Activity 销毁），上一个 Activity 会恢复（界面会恢复到上一个状态）。堆栈中的 Activity 永远不会重新排列，只会被送入和退出，在当前 Activity 启动时被送入堆栈，在用户使用<strong>返回</strong>按钮离开时从堆栈中退出。因此，返回堆栈按照“后进先出”的对象结构运作</p>
<p><img src="https://developer.android.google.cn/images/fundamentals/diagram_backstack.png" alt="img"></p>
<ul>
<li><code>&quot;singleTop&quot;</code>（栈顶模式）</li>
</ul>
<p>如果当前任务的顶部已存在 Activity 的实例，则系统会通过调用其 <code>onNewIntent()</code> 方法来将 intent 转送给该实例，而不是创建 Activity 的新实例。</p>
<ul>
<li><code>&quot;singleTask&quot;</code>（栈内模式）</li>
</ul>
<p>系统会创建新任务，并实例化新任务的根 Activity。但是，如果另外的任务中已存在该 Activity 的实例，则系统会通过调用其 <code>onNewIntent()</code> 方法将 intent 转送到该现有实例，而不是创建新实例。Activity 一次只能有一个实例存在。</p>
<ul>
<li><code>&quot;singleInstance&quot;</code></li>
</ul>
<p>与 “singleTask” 相似，唯一不同的是系统不会将任何其他 Activity 启动到包含该实例的任务中。该 Activity 始终是其任务唯一的成员；由该 Activity 启动的任何 Activity 都会在其他的任务中打开。</p>
<p>standard和singleTop为一类，在这两种模式中，activity可以多次进行实例化，实例可以归属于任何任务。二者唯一的不同是启动新的activity在栈顶时是否创建新的实例。在大多数情况下，应该使用这两种模式。</p>
<p>singleTask和singleInstance为一类，指定为这两种模式的Activity 只能启动任务。它们始终位于 Activity 堆栈的根位置。指定为<code>singleTask</code>的Activity 允许其他 Activity 成为其任务的一部分，但singleInstance则只允许自己是任务中唯一的activity。</p>
<h3 id="使用Intent标记"><a href="#使用Intent标记" class="headerlink" title="使用Intent标记"></a>使用Intent标记</h3><p>除了在XML中配置启动模式外，还可以使用intent标记来修改activity和任务的关系。</p>
<ul>
<li><code>FLAG_ACTIVITY_NEW_TASK</code></li>
</ul>
<p>在新任务中启动 Activity。如果您现在启动的 Activity 已经有任务在运行，则系统会将该任务转到前台并恢复其最后的状态，而 Activity 将在 <code>onNewIntent()</code> 中收到新的 intent。</p>
<p>这与上一节中介绍的 <code>&quot;singleTask&quot;</code> <code>launchMode</code>值产生的行为相同。</p>
<ul>
<li><code>FLAG_ACTIVITY_SINGLE_TOP</code></li>
</ul>
<p>如果要启动的 Activity 是当前 Activity（即位于返回堆栈顶部的 Activity），则现有实例会收到对 <code>onNewIntent()</code> 的调用，而不会创建 Activity 的新实例。</p>
<p>这与上一节中介绍的 <code>&quot;singleTop&quot;</code> <code>launchMode</code>值产生的行为相同。</p>
<ul>
<li><code>FLAG_ACTIVITY_CLEAR_TOP</code></li>
</ul>
<p>如果要启动的activity已经在当前任务中运行，则不会启动该activity的新实例，而是会销毁位于它之上的所有其它activity，并通过 <code>onNewIntent()</code> 将此 intent 传送给它的已恢复实例（现在位于堆栈顶部）。</p>
<p>没有对应的的launchMode</p>
<p>把我看懵了。。。。。这三个+启动模式的四个，有点难理解。</p>
<h2 id="Application相关"><a href="#Application相关" class="headerlink" title="Application相关"></a>Application相关</h2><h3 id="Application类"><a href="#Application类" class="headerlink" title="Application类"></a>Application类</h3><p>参考资料：</p>
<p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/f665366b2a47">Android：全面解析 熟悉而陌生 的Application类使用 - 简书 (jianshu.com)</a></p>
<p><a target="_blank" rel="noopener" href="https://developer.android.google.cn/reference/kotlin/android/app/Application?hl=en">Application  | Android Developers (google.cn)</a></p>
<p>第一篇写的很简单易懂，也很全面，以至于我感觉没有什么需要写的了，进行一下总结，然后补充一点没提到的部分吧</p>
<p><strong>总结</strong></p>
<ul>
<li>定义：维护全局应用程序状态的基类，继承自Context类</li>
<li>创建：每个Android App运行时，会首先自动创建Application 类并实例化 Application 对象，且只有一个。</li>
<li>生命周期：和整个安卓APP的生命周期相同，是最长的</li>
<li>常用方法：<ul>
<li><code>onCreate()</code>：<code>Application</code> 实例创建时调用，初始化应用程序级别的资源、设置全局恭喜数据。默认实现为空</li>
<li><code>onConfigurationChanged()</code>：应用程序配置信息改变时调用，监听配置信息的改变。</li>
<li><code>onTrimMemory()</code>：通知应用程序当前内存使用情况（以内存级别进行识别），针对内存清空程序进行相应的操作，如释放相关资源，降低自身被杀死的可能。Android 4以后可以使用</li>
<li><code>onLowMemory()</code>：监听系统整体内存较低的时刻，在Android 4以前使用，之后使用<code>onTrimMemory</code>。</li>
<li><code>registerActivityLifecycleCallbacks()</code>：注册对应用程序内所有Activity的生命周期监听，内包含各个生命周期的回调。当然还有一个取消监听的un方法。</li>
<li><code> onTerminate()</code>：程序结束时调用，但仅可用于虚拟机。默认实现为空。</li>
</ul>
</li>
<li>使用方法：自定义Applicatio的子类继承，在清单文件中使用<code>android:name</code>进行注册，使用。</li>
</ul>
<p><strong>补充方法</strong></p>
<p><code>getProcessName()</code>：返回当前进程的名称，默认进程名称与其包名称相同。在API28以后增加。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getProcessName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> ActivityThread.currentProcessName();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意</strong></p>
<p>多进程App中不止一个Application实例，以上讨论仅仅是单进程App。</p>
<p>文章一中提到，Application是单例模式，这个有待证实，看Application类的源码，是没有针对单例处理的，而是由系统设置Application只有一个，另外Application是有public的构造函数的，但是不要去new使用。</p>
<h3 id="lt-application-gt-标签"><a href="#lt-application-gt-标签" class="headerlink" title="&lt;application&gt;标签"></a><code>&lt;application&gt;</code>标签</h3><p>官方文档：<a target="_blank" rel="noopener" href="https://developer.android.google.cn/guide/topics/manifest/application-element">  | Android 开发者  | Android Developers (google.cn)</a></p>
<p>应用的声明。此元素包含用于声明每个应用组件的子元素，并且具有会影响所有组件的属性。被包含在清单文件的<code>&lt;manifest&gt;</code>标签下，包含的标签较多，选几个重要的记一下：</p>
<p><code>android:banner</code></p>
<p>一种可绘制资源，可为其关联项提供扩展图形横幅。它可以与 <code>&lt;application&gt;</code> 标记一起使用，为所有应用 Activity 提供默认横幅；也可以与<code>&lt;activity&gt;</code>标记一起使用，为特定 Activity 提供横幅。</p>
<p><code>android:debuggable</code></p>
<p>是否可以调试应用（即使在处于用户模式的设备上运行时），默认为false。</p>
<p><code>android:enabled</code></p>
<p>Android 系统是否可以实例化应用的组件，一般用来指定是否启用该组件，默认为true。</p>
<p><code>android:hardwareAccelerated</code></p>
<p>是否应为此应用中的所有 Activity 和视图启用硬件加速渲染，在API14以上默认关闭，以下默认开启。若开启，请对此进行测试，保证可以正确渲染。</p>
<p><code>android:icon</code></p>
<p>整个应用的图标，以及每个应用组件的默认图标。必须将此属性设为对包含图片的可绘制资源（例如 <code>&quot;@drawable/icon&quot;</code>）的引用。没有默认图标。</p>
<p><code>android:label</code></p>
<p>整个应用的用户可读标签，以及每个应用组件的默认标签。应将标签设为对字符串资源的引用，以便可以像界面中的其他字符串一样进行本地化。</p>
<p><code>android:logo</code></p>
<p>整个应用的徽标，以及 Activity 的默认徽标。必须将此属性设为对包含图片的可绘制资源（例如 <code>&quot;@drawable/logo&quot;</code>）的引用。没有默认徽标。注意区分这个和icon属性，logo一般是用来作为ActionBar上的应用标志，而icon则是指app在桌面上显示的图标。</p>
<p><code>android:name</code></p>
<p>为应用实现的 <code>Application</code> 子类的完全限定名称。应用进程启动后，此类会在应用的所有组件之前进行实例化。</p>
<p>该子类是可选的；大多数应用都不需要它。在没有子类的情况下，Android 会使用 Application 基类的实例。</p>
<p><code>android:theme</code></p>
<p>对样式资源的引用，用于为应用中的所有 Activity 定义默认主题背景。各个 Activity 可以通过设置自己的 <code>theme</code> 属性来替换默认值。</p>
<p><code>android:taskAffinity</code></p>
<p>上面启动模式中有讲，用来设置应用中默认的Activity粘性（粘性一词用得很奇妙）</p>
<p>最后，<code>&lt;application&gt;</code>标签的很多属性和Activity标签和其它组件的属性有相同之处，可以触类旁通。</p>

    </div>

    
    
    

    <footer class="post-footer">

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2021/05/08/Android%20UI%E5%AD%A6%E4%B9%A0/" rel="prev" title="">
                  <i class="fa fa-chevron-left"></i> 
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2021/05/12/%E5%AE%89%E5%8D%93service%E6%9C%8D%E5%8A%A1/" rel="next" title="">
                   <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">wxc</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  






  





</body>
</html>
